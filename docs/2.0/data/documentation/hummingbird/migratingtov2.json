{"metadata":{"roleHeading":"Article","title":"Migrating to Hummingbird v2","role":"article","images":[{"type":"icon","identifier":"logo.png"}]},"abstract":[{"text":"Migration guide for converting Hummingbird v1 applications to Hummingbird v2","type":"text"}],"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the short lifetime of the Hummingbird server framework there have been many major changes to the Swift language. Hummingbird v2 has been designed to take advantage of all the latest changes to Swift. In addition Hummingbird v1 was our first attempt at writing a server framework and we didn’t necessarily get everything right, so v2 includes some changes where we feel we made the wrong design first time around. Below we cover most of the major changes in the library and how you should deal with them."}]},{"level":2,"type":"heading","text":"Symbol names","anchor":"Symbol-names"},{"inlineContent":[{"text":"The first thing you will notice when moving to v2 are the symbol names. In Version 2 of Hummingbird we have removed the “HB” prefix from all the symbols.","type":"text"}],"type":"paragraph"},{"level":2,"text":"SwiftNIO and Swift Concurrency","type":"heading","anchor":"SwiftNIO-and-Swift-Concurrency"},{"inlineContent":[{"text":"In the time that the Hummingbird server framework has been around there has been a seismic shift in the Swift language. When it was first in development the initial pitches for Swift Concurrency were only just being posted. It wasn’t for another 9 months before we actually saw a release of Swift with any concurrency features. As features have become available we have tried to support them but the internals of Hummingbird were still SwiftNIO EventLoop based and held us back from providing full support for Concurrency.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Hummingbird v2 is now exclusively Swift concurrency based. All EventLoop based APIs have been removed."}],"type":"paragraph"},{"text":"Using EventLoop-based Libraries","type":"heading","anchor":"Using-EventLoop-based-Libraries","level":3},{"type":"paragraph","inlineContent":[{"text":"If you have libraries you are calling into that still only provide EventLoop based APIs you can convert them to Swift concurrency using the ","type":"text"},{"type":"codeVoice","code":"get"},{"type":"text","text":" method from "},{"code":"EventLoopFuture","type":"codeVoice"},{"text":".","type":"text"}]},{"syntax":"swift","code":["let value = try await eventLoopBasedFunction().get()"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"If you need to provide an "},{"code":"EventLoopGroup","type":"codeVoice"},{"text":", use either the one you provided to ","type":"text"},{"type":"codeVoice","code":"Application.init"},{"type":"text","text":" or "},{"code":"MultiThreadedEventLoopGroup.singleton","type":"codeVoice"},{"type":"text","text":". And when you need an "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" use "},{"type":"codeVoice","code":"EventLoopGroup.any"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["let service = MyService(eventLoopGroup: MultiThreadedEventLoopGroup.singleton)","let result = try await service.doStuff(eventLoop: MultiThreadedEventLoopGroup.singleton.any()).get()"],"type":"codeListing"},{"inlineContent":[{"text":"Otherwise any ","type":"text"},{"type":"codeVoice","code":"EventLoopFuture"},{"text":" based logic you had will have to be converted to Swift concurrency. The advantage of this is, it should be a lot easier to read after.","type":"text"}],"type":"paragraph"},{"text":"Extending Application and Request","anchor":"Extending-Application-and-Request","level":2,"type":"heading"},{"inlineContent":[{"text":"In Hummingbird v1 you could extend the ","type":"text"},{"type":"codeVoice","code":"Application"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Request"},{"text":" types to include your own custom data. This is no longer possible in version 2.","type":"text"}],"type":"paragraph"},{"level":3,"text":"Application","type":"heading","anchor":"Application"},{"inlineContent":[{"type":"text","text":"In the case of the application we decided we didn’t want to make "},{"code":"Application","type":"codeVoice"},{"type":"text","text":" this huge mega global that held everything. We have moved to a model of explicit dependency injection."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For each route controller you supply the dependencies you need at initialization, instead of extracting them from the application when you use them. This makes it clearer what dependencies you are using in each controller."}]},{"code":["struct UserController {","    \/\/ The user authentication routes use fluent and session storage","    init(fluent: Fluent, sessions: SessionStorage) {","        ...","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Request and RequestContext","anchor":"Request-and-RequestContext","level":3},{"inlineContent":[{"type":"text","text":"We have replaced extending of "},{"code":"Request","type":"codeVoice"},{"type":"text","text":" with a custom request context type that is passed along with the request. This means "},{"code":"Request","type":"codeVoice"},{"text":" is just the HTTP request data (as it should be). The additional request context parameter will hold any custom data required. In situations in the past where you would use data attached to ","type":"text"},{"code":"Request","type":"codeVoice"},{"type":"text","text":", you should now use the context."}],"type":"paragraph"},{"type":"codeListing","code":["router.get { request, context in","    \/\/ logger is attached to the context","    context.logger.info(\"The logger attached to the context includes the request's id.\")","    \/\/ request decoder is attached to the context instead of the application","    let myObject = try await request.decode(as: MyObject.self, context: context)","}"],"syntax":"swift"},{"inlineContent":[{"text":"The request context is a generic value. As long as it conforms to ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContext"},{"type":"text","text":" it can hold anything you like."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ Example request context with an additional data attached","struct MyRequestContext: RequestContext {","    \/\/ required by RequestContext","    var coreContext: CoreRequestContextStorage","    var additionalData: String?","","    \/\/ required by RequestContext","    init(source: Source) {","        self.coreContext = .init(source: source)","        self.additionalData = nil","    }","}"]},{"inlineContent":[{"type":"text","text":"When you create your router you pass in the request context type you’d like to use. If you don’t pass one in it will default to using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/BasicRequestContext"},{"text":" which provides enough data for the router to run but not much else.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let router = Router(context: MyRequestContext.self)"]},{"name":"Important","type":"aside","content":[{"inlineContent":[{"type":"text","text":"This feature is at the heart of Hummingbird 2, so we recommend reading our guide to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContexts"},{"text":".","type":"text"}],"type":"paragraph"}],"style":"important"},{"anchor":"Router","level":2,"type":"heading","text":"Router"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of creating an application and adding routes to it, in v2 you create a router and add routes to it and then create an application using that router."}]},{"columns":[{"content":[{"text":"Hummingbird 1","anchor":"Hummingbird-1","level":3,"type":"heading"},{"type":"codeListing","syntax":"swift","code":["let app = Application()","app.router.get { request in","    \"hello\"","}"]}],"size":1},{"size":1,"content":[{"text":"Hummingbird 2","type":"heading","anchor":"Hummingbird-2","level":3},{"code":["let router = Router()","router.get { request, context in","    \"hello\"","}","let app = Application(router: router)"],"syntax":"swift","type":"codeListing"}]}],"numberOfColumns":2,"type":"row"},{"inlineContent":[{"type":"text","text":"When we are passing in the router we are actually passing in a type that can build a "},{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HTTPResponder","type":"reference","isActive":true},{"type":"text","text":" a protocol for a type with one function that takes a request and context and returns a response."}],"type":"paragraph"},{"level":3,"anchor":"Router-Builder","text":"Router Builder","type":"heading"},{"inlineContent":[{"text":"An alternative router is also provided in the ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdRouter","isActive":true},{"text":" module. It uses a result builder to generate the router.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let router = RouterBuilder(context: MyContext.self) {","    \/\/ add logging middleware","    LogRequestsMiddleware(.info)","    \/\/ add route to return ok","    Get(\"health\") { _,_ -> HTTPResponse.Status in","        .ok","    }","    \/\/ for all routes starting with '\/user'","    RouteGroup(\"user\") {","        \/\/ add router supplied by UserController","        UserController(fluent: fluent).routes()","    }","}","let app = Application(router: router)"]},{"anchor":"Miscellaneous","type":"heading","level":2,"text":"Miscellaneous"},{"type":"paragraph","inlineContent":[{"text":"Below is a list of other smaller changes that might catch you out","type":"text"}]},{"level":3,"anchor":"Request-body-streaming","text":"Request body streaming","type":"heading"},{"inlineContent":[{"text":"In Hummingbird v1 it was assumed request bodies would be collated into one ByteBuffer and if you didn’t want that to happen you had to flag the route to not collate your request body. In v2 this assumption has been reversed. It is assumed that request bodies are a stream of buffers and if you want to collate them into one buffer you need to call a method to do that.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To treat the request body as a stream of buffers"}],"type":"paragraph"},{"code":["router.put { request, context in","    for try await buffer in request.body {","        process(buffer)","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"To treat the request body as a single buffer.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["router.put { request, context in","    let body = try await request.body.collate(maxSize: 1_000_000)","    process(body)","}"],"type":"codeListing"},{"level":3,"anchor":"OpenAPI-style-URI-capture-parameters","text":"OpenAPI style URI capture parameters","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"In Hummingbird v1.3.0 partial path component matching and capture was introduced. For this a new syntax was introduced for parameter capture: ","type":"text"},{"code":"${parameter}","type":"codeVoice"},{"text":" alongside the standard ","type":"text"},{"code":":parameter","type":"codeVoice"},{"type":"text","text":" syntax. It has been decided to change the new form of the syntax to "},{"type":"codeVoice","code":"{parameter}"},{"text":" to coincide with the syntax used by OpenAPI.","type":"text"}]},{"level":3,"text":"HummingbirdFoundation","anchor":"HummingbirdFoundation","type":"heading"},{"inlineContent":[{"text":"HummingbirdFoundation has been merged into Hummingbird. It was felt the gains from separating out the code relying on Foundation were not enough for the awkwardness it created. Eventually we hope to limit our exposure to only the elements of Foundation that will be in FoundationEssentials module from the newly developed ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-foundation","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"text":"Generic Application","type":"heading","level":3,"anchor":"Generic-Application"},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Application","isActive":true},{"text":" is a generic type with two different type parameters. Passing around the concrete type is complex as you need to work out the type parameters. They might not be immediately obvious. Instead it is easier to pass around the opaque type ","type":"text"},{"type":"codeVoice","code":"some ApplicationProtocol"},{"text":".","type":"text"}]},{"code":["func buildApplication() -> some ApplicationProtocol {","    ...","    let app = Application(router: router)","    return app","}"],"type":"codeListing","syntax":"swift"}],"kind":"content"}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterGuide","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContexts","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MiddlewareGuide","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterBuilderGuide","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ServiceLifecycle","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Testing","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData"],"anchor":"Hummingbird-Server","title":"Hummingbird Server","generated":true}],"schemaVersion":{"patch":0,"minor":3,"major":0},"sections":[],"kind":"article","identifier":{"url":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MigratingToV2","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/com.opticalaberration.hummingbird\/documentation\/index"]]},"references":{"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RequestContexts":{"role":"article","type":"topic","url":"\/documentation\/hummingbird\/requestcontexts","abstract":[{"text":"Controlling contextual data provided to middleware and route handlers","type":"text"}],"images":[{"type":"icon","identifier":"logo.png"}],"title":"Request Contexts","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContexts","kind":"article"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RouterBuilderGuide":{"images":[{"identifier":"logo.png","type":"icon"}],"type":"topic","role":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterBuilderGuide","abstract":[{"type":"text","text":"Building your router using a result builder."}],"kind":"article","url":"\/documentation\/hummingbird\/routerbuilderguide","title":"Result Builder Router"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/HTTPResponder":{"abstract":[{"text":"Protocol for object that produces a response given a request","type":"text"}],"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HTTPResponder","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"HTTPResponder","kind":"identifier"}],"title":"HTTPResponder","kind":"symbol","url":"\/documentation\/hummingbird\/httpresponder","navigatorTitle":[{"text":"HTTPResponder","kind":"identifier"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/Testing":{"images":[{"type":"icon","identifier":"logo.png"}],"type":"topic","role":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Testing","abstract":[{"text":"Using the HummingbirdTesting framework to test your application","type":"text"}],"kind":"article","url":"\/documentation\/hummingbird\/testing","title":"Testing"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/EncodingAndDecoding":{"images":[{"type":"icon","identifier":"logo.png"}],"type":"topic","role":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding","abstract":[{"text":"Hummingbird uses ","type":"text"},{"type":"codeVoice","code":"Codable"},{"text":" to decode requests and encode responses.","type":"text"}],"kind":"article","url":"\/documentation\/hummingbird\/encodinganddecoding","title":"Encoding and Decoding"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/MiddlewareGuide":{"images":[{"type":"icon","identifier":"logo.png"}],"type":"topic","role":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MiddlewareGuide","abstract":[{"text":"Processing requests and responses outside of request handlers.","type":"text"}],"kind":"article","url":"\/documentation\/hummingbird\/middlewareguide","title":"Middleware"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdCore/Request":{"abstract":[{"text":"Holds all the values required to process a request","type":"text"}],"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/Request","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Request","kind":"identifier"}],"title":"Request","kind":"symbol","url":"\/documentation\/hummingbirdcore\/request","navigatorTitle":[{"kind":"identifier","text":"Request"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ServiceLifecycle":{"role":"article","type":"topic","url":"\/documentation\/hummingbird\/servicelifecycle","abstract":[{"text":"Integration with Swift Service Lifecycle","type":"text"}],"images":[{"type":"icon","identifier":"logo.png"}],"title":"Service Lifecycle","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ServiceLifecycle","kind":"article"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdRouter":{"abstract":[{"text":"Alternative result builder based router for Hummingbird.","type":"text"}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdRouter","type":"topic","role":"collection","kind":"symbol","title":"HummingbirdRouter","url":"\/documentation\/hummingbirdrouter","images":[{"type":"icon","identifier":"logo.png"}]},"doc://com.opticalaberration.hummingbird/documentation/index":{"abstract":[{"text":"Documentation for Hummingbird the lightweight, flexible, modern server framework.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/index","role":"collection","title":"Hummingbird Documentation","kind":"article","url":"\/documentation\/index","images":[{"type":"icon","identifier":"logo.png"}]},"logo.png":{"type":"image","identifier":"logo.png","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/com.opticalaberration.hummingbird\/logo.png"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ErrorHandling":{"role":"article","type":"topic","url":"\/documentation\/hummingbird\/errorhandling","abstract":[{"text":"How to build errors for the server to return.","type":"text"}],"images":[{"identifier":"logo.png","type":"icon"}],"title":"Error Handling","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","kind":"article"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/LoggingMetricsAndTracing":{"images":[{"identifier":"logo.png","type":"icon"}],"type":"topic","role":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","abstract":[{"text":"Considered the three pillars of observability, logging, metrics and tracing provide different ways of viewing how your application is working.","type":"text"}],"kind":"article","url":"\/documentation\/hummingbird\/loggingmetricsandtracing","title":"Logging, Metrics and Tracing"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RouterGuide":{"images":[{"identifier":"logo.png","type":"icon"}],"type":"topic","role":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterGuide","abstract":[{"type":"text","text":"The router directs requests to their handlers based on the contents of their path."}],"kind":"article","url":"\/documentation\/hummingbird\/routerguide","title":"Router"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/BasicRequestContext":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/BasicRequestContext","role":"symbol","type":"topic","url":"\/documentation\/hummingbird\/basicrequestcontext","title":"BasicRequestContext","navigatorTitle":[{"kind":"identifier","text":"BasicRequestContext"}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"BasicRequestContext","kind":"identifier"}],"abstract":[{"type":"text","text":"Implementation of a basic request context that supports everything the Hummingbird library needs"}],"kind":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/Application":{"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Application"}],"url":"\/documentation\/hummingbird\/application","navigatorTitle":[{"text":"Application","kind":"identifier"}],"kind":"symbol","type":"topic","title":"Application","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Application","abstract":[{"text":"Application type bringing together all the components of Hummingbird","type":"text"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/PersistentData":{"kind":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData","type":"topic","role":"article","title":"Persistent data","url":"\/documentation\/hummingbird\/persistentdata","images":[{"type":"icon","identifier":"logo.png"}],"abstract":[{"type":"text","text":"How to persist data between requests to your server."}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RequestContext":{"abstract":[{"type":"text","text":"Protocol that all request contexts should conform to. A RequestContext is a statically typed metadata container for information"},{"text":" ","type":"text"},{"type":"text","text":"that is associated with a "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/Request"},{"type":"text","text":", and is therefore instantiated alongside the request."}],"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContext","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"RequestContext","kind":"identifier"}],"title":"RequestContext","kind":"symbol","url":"\/documentation\/hummingbird\/requestcontext","navigatorTitle":[{"text":"RequestContext","kind":"identifier"}]},"https://github.com/apple/swift-foundation":{"title":"Swift Foundation","type":"link","identifier":"https:\/\/github.com\/apple\/swift-foundation","titleInlineContent":[{"text":"Swift Foundation","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-foundation"}}}